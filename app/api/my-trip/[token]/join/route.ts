/**
 * Guest Self-Registration API
 * POST /api/my-trip/[token]/join - Register as a guest via shareable link
 * GET /api/my-trip/[token]/join - Get trip info for the join page
 */

import { NextRequest, NextResponse } from 'next/server';
import { withErrorHandling, RouteContext } from '@/lib/api/middleware/error-handler';
import { tripProposalService } from '@/lib/services/trip-proposal.service';
import { rateLimiters } from '@/lib/api/middleware/rate-limit';
import { checkRateLimit } from '@/lib/api/middleware/rate-limit';
import { z } from 'zod';

interface RouteParams {
  token: string;
}

const JoinGuestSchema = z.object({
  name: z.string().min(1, 'Name is required').max(255),
  email: z.string().email('Valid email required'),
  phone: z.string().max(50).optional().or(z.literal('')),
});

/**
 * GET /api/my-trip/[token]/join
 * Returns trip info for the registration page (public)
 */
export const GET = withErrorHandling<unknown, RouteParams>(
  async (request: NextRequest, context: RouteContext<RouteParams>) => {
    const { token } = await context.params;

    // Validate token format: alphanumeric, 32+ chars (generated by generateSecureString(64))
    if (!token || !/^[A-Za-z0-9]{32,}$/.test(token)) {
      return NextResponse.json(
        { success: false, error: 'Trip not found' },
        { status: 404 }
      );
    }

    const proposal = await tripProposalService.getByAccessToken(token);
    if (!proposal) {
      return NextResponse.json(
        { success: false, error: 'Trip not found' },
        { status: 404 }
      );
    }

    // Only allow joining accepted/booked trips or those in active planning
    const canJoin = ['accepted', 'booked'].includes(proposal.status) ||
      proposal.planning_phase !== 'proposal';

    if (!canJoin) {
      return NextResponse.json(
        { success: false, error: 'This trip is not accepting guests yet' },
        { status: 403 }
      );
    }

    const guestCount = await tripProposalService.getGuestCount(proposal.id);
    const atCapacity = proposal.max_guests ? guestCount >= proposal.max_guests : false;

    // Build response — only show counts if configured
    const data: Record<string, unknown> = {
      trip_title: proposal.trip_title || `Trip for ${proposal.customer_name}`,
      start_date: proposal.start_date,
      end_date: proposal.end_date,
      at_capacity: atCapacity,
      max_guests: proposal.max_guests,
    };

    if (proposal.show_guest_count_to_guests) {
      data.guest_count = guestCount;
      data.min_guests = proposal.min_guests;
      data.spots_remaining = proposal.max_guests ? proposal.max_guests - guestCount : null;
    }

    // Dynamic pricing info
    if (proposal.dynamic_pricing_enabled && proposal.show_guest_count_to_guests) {
      const estimate = await tripProposalService.getPerPersonEstimate(proposal.id);
      data.dynamic_pricing = {
        current_per_person: estimate.current_per_person,
        ceiling_price: estimate.ceiling_price,
        floor_price: estimate.floor_price,
        min_guests: estimate.min_guests,
        max_guests: estimate.max_guests,
      };
    }

    return NextResponse.json({ success: true, data });
  }
);

/**
 * POST /api/my-trip/[token]/join
 * Register a new guest via the shareable link
 */
export const POST = withErrorHandling<unknown, RouteParams>(
  async (request: NextRequest, context: RouteContext<RouteParams>) => {
    // Rate limit: 10 submissions per hour per IP
    const rateLimited = await checkRateLimit(request, rateLimiters.publicSubmit);
    if (rateLimited) return rateLimited;

    const { token } = await context.params;

    // Validate token format: alphanumeric, 32+ chars (generated by generateSecureString(64))
    if (!token || !/^[A-Za-z0-9]{32,}$/.test(token)) {
      return NextResponse.json(
        { success: false, error: 'Trip not found' },
        { status: 404 }
      );
    }

    const proposal = await tripProposalService.getByAccessToken(token);
    if (!proposal) {
      return NextResponse.json(
        { success: false, error: 'Trip not found' },
        { status: 404 }
      );
    }

    // Only allow joining accepted/booked trips or those in active planning
    const canJoin = ['accepted', 'booked'].includes(proposal.status) ||
      proposal.planning_phase !== 'proposal';

    if (!canJoin) {
      return NextResponse.json(
        { success: false, error: 'This trip is not accepting guests yet' },
        { status: 403 }
      );
    }

    const body = await request.json();
    const parseResult = JoinGuestSchema.safeParse(body);
    if (!parseResult.success) {
      return NextResponse.json(
        { success: false, error: 'Invalid input', details: parseResult.error.flatten().fieldErrors },
        { status: 400 }
      );
    }

    const { name, email, phone } = parseResult.data;

    // Check for duplicate email using efficient direct query (not loading all guests)
    const isDuplicate = await tripProposalService.isEmailRegistered(proposal.id, email);
    if (isDuplicate) {
      return NextResponse.json(
        { success: false, error: 'Unable to complete registration. If you have already registered, check your email for your trip details.' },
        { status: 409 }
      );
    }

    // Determine RSVP status based on approval setting
    const rsvpStatus = proposal.guest_approval_required ? 'pending' : 'confirmed';

    // Create the guest with registration and RSVP fields set atomically
    const guest = await tripProposalService.addGuest(proposal.id, {
      name,
      email,
      phone: phone || undefined,
      is_registered: true,
      rsvp_status: rsvpStatus,
    });

    return NextResponse.json(
      {
        success: true,
        data: {
          guest_access_token: guest.guest_access_token,
          rsvp_status: rsvpStatus,
          needs_approval: proposal.guest_approval_required,
        },
        message: proposal.guest_approval_required
          ? 'Registration submitted — awaiting approval'
          : 'Successfully registered!',
      },
      { status: 201 }
    );
  }
);
